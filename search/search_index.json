{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Time App Documentation","text":"<p>Time is a web application designed to calculate working hours. Built using modern web technologies and deployed via Firebase Hosting.</p>"},{"location":"architecture/","title":"Overview","text":"<p>The application is a simple time calculator built with React and TypeScript. Although the feature set is small, the architecture follows scalable patterns suitable for larger applications.</p>"},{"location":"architecture/#key-architectural-concepts","title":"Key Architectural Concepts","text":""},{"location":"architecture/#component-based-structure","title":"Component-Based Structure","text":"<p>All UI pieces are implemented as isolated React components with their own state and props. This simplifies testing and maintenance.</p>"},{"location":"architecture/#business-logic-isolation","title":"Business Logic Isolation","text":"<p>Core time-related logic is placed in utility modules under src/util. This avoids mixing UI rendering with business rules.</p>"},{"location":"architecture/#state-management","title":"State Management","text":"<p>Local component state is used because the application is small. The design allows easy migration to Zustand, Redux, or other global state systems if the need arises.</p>"},{"location":"architecture/#library-choices","title":"Library Choices","text":"<ul> <li>React \u2013 UI rendering</li> <li>Day.js \u2013 Lightweight date/time manipulation</li> <li>Material UI \u2013 UI components</li> <li>Vite \u2013 Fast development build tool</li> <li>TypeScript \u2013 Static typing and improved maintainability</li> </ul>"},{"location":"architecture/#folder-structure","title":"Folder Structure","text":"<pre><code>src/\n  components/   # Reusable UI components\n  util/         # Time calculation and formatting utilities\n  tests/        # Unit and integration tests\n  App.tsx       # Main application entry point\n</code></pre>"},{"location":"architecture/#release-and-versioning-architecture","title":"Release and Versioning Architecture","text":"<p>The project uses a fully automated release pipeline powered by semantic-release. This system analyzes commit messages, determines the next semantic version, generates release notes, updates the changelog, and publishes a GitHub Release without any manual steps.</p>"},{"location":"architecture/#key-concepts","title":"Key Concepts","text":"<ul> <li>Conventional Commits are used as the single source of truth for determining the release type (patch, minor, major).</li> <li>semantic-release performs:</li> <li>Version analysis (<code>fix</code>, <code>feat</code>, <code>feat!</code>)</li> <li>Automatic version bump of <code>package.json</code></li> <li>Changelog generation (stored under <code>docs/changelog.md</code>)</li> <li>Git tagging</li> <li>Publishing GitHub Releases</li> </ul>"},{"location":"architecture/#why-this-matters","title":"Why this matters","text":"<p>This architecture ensures consistent versioning, reproducible releases, and transparent change history. It also removes human error from the release process and integrates seamlessly with the CI/CD pipelines.</p>"},{"location":"architecture/#design-goals","title":"Design Goals","text":"<ul> <li>High readability and clean code</li> <li>Full testability</li> <li>Separation of concerns</li> <li>Deterministic time results for reliable tests</li> </ul>"},{"location":"architecture/#diagram","title":"Diagram","text":""},{"location":"cicd/","title":"Introduction","text":"<p>This project demonstrates a complete CI/CD setup built around GitHub Actions. The pipeline ensures reliable testing, preview environments, and production deployment.</p>"},{"location":"cicd/#cicd-pipeline-stages","title":"CI/CD Pipeline Stages","text":"<ol> <li> <p>Pull Request Workflow</p> <ul> <li>Install dependencies</li> <li>Run ESLint</li> <li>Run Jest unit tests with coverage</li> <li>Build the project</li> <li>Deploy a temporary Firebase Hosting preview channel</li> <li>Run Playwright E2E tests against the preview environment</li> <li>Publish Playwright reports as build artifacts</li> </ul> </li> <li> <p>Production Deployment Workflow Triggered on pushes to main:</p> <ul> <li>Install dependencies</li> <li>Lint and test</li> <li>Upload coverage to Codecov</li> <li>Build production output</li> <li>Deploy to Firebase Hosting</li> <li>Run Playwright tests against production</li> <li>Publish reports and documentation to GitHub Pages</li> </ul> </li> <li> <p>Scheduled Dependency Updates Dependabot runs weekly to update direct dependencies except major versions.</p> </li> </ol>"},{"location":"cicd/#automated-release-workflow","title":"Automated Release Workflow","text":"<p>Releases are fully automated and triggered on each push to the <code>main</code> branch. The CI pipeline executes semantic-release, which performs the following steps:</p> <ol> <li>Analyze commit messages using the Conventional Commits format.</li> <li>Determine the next version (patch, minor, major).</li> <li>Update the changelog (<code>docs/changelog.md</code>) using the official changelog plugin.</li> <li>Update <code>package.json</code> with the new version number.</li> <li>Create and push a Git tag for the release.</li> <li>Create a GitHub Release including auto-generated release notes.</li> <li>Commit updated files back to the repository.</li> </ol>"},{"location":"cicd/#branch-strategy","title":"Branch Strategy","text":"<p>Release automation only runs on the <code>main</code> branch. Pull requests are validated using a PR title linter to ensure that all PR titles follow the Conventional Commits format. This guarantees predictable and consistent versioning during the release step.</p>"},{"location":"cicd/#benefits","title":"Benefits","text":"<ul> <li>No manual tagging  </li> <li>No manual changelog editing  </li> <li>Prevents inconsistent versioning  </li> <li>Provides clear release notes for every version  </li> <li>Works seamlessly with automated deployments</li> </ul>"},{"location":"cicd/#goals-of-the-pipeline","title":"Goals of the Pipeline","text":"<ul> <li>Prevent merging untested code</li> <li>Provide preview environments for every pull request</li> <li>Automatically validate UI behavior with E2E tests</li> <li>Produce transparent build artifacts and reports</li> <li>Enforce code quality with linting and formatting</li> </ul>"},{"location":"cicd/#diagram","title":"Diagram","text":""},{"location":"dev-tips/","title":"Some useful commands for Developers","text":""},{"location":"dev-tips/#playwright","title":"Playwright","text":"<pre><code># start all tests\nnpx playwright test\n\n# debug one test\nnpx playwright test tests/time.spec.ts:68 --project=firefox --headed --debug\n</code></pre>"},{"location":"dev-tips/#eslint-prettier","title":"Eslint &amp; Prettier","text":"<pre><code># start check\nnpm run lint\n\n# fix\nnpm run lint -- --fix\nnpx prettier --write .\n</code></pre>"},{"location":"dev-tips/#mkdocs","title":"MkDocs","text":"<pre><code>mkdocs serve\n</code></pre>"},{"location":"dev-tips/#pr-title-rules","title":"PR Title Rules","text":"<p>valid titles:</p> <pre><code>feat: add dark mode\nfix: correct time calculation\nchore: update dependencies\nrefactor: cleanup input parsing\ndocs: add architecture overview\ntest: improve unit tests\nperf: optimize render loop\nfeat!: change initial input format\n</code></pre>"},{"location":"playwright/","title":"Overview","text":"<p>Playwright is used for automated end-to-end tests that run both on preview deployments and the production environment.</p>"},{"location":"playwright/#why-playwright","title":"Why Playwright?","text":"<ul> <li>Real browser testing (Chromium, Firefox, WebKit)</li> <li>Automatic waiting and reliable async handling</li> <li>Easy integration with GitHub Actions</li> </ul>"},{"location":"playwright/#test-scope","title":"Test Scope","text":"<ul> <li>Rendering of input fields and controls</li> <li>Time calculation workflow</li> <li>Increment/decrement interactions</li> <li>Validation of output formatting</li> <li>Testing the application in a real hosted environment</li> </ul>"},{"location":"playwright/#ci-integration","title":"CI Integration","text":"<p>The Playwright tests run in two environments:</p> <ol> <li> <p>Pull Request Preview Ensures changes don\u2019t break UI before merging.</p> </li> <li> <p>Production Deployment Verifies that the deployed version behaves as expected.</p> </li> </ol>"},{"location":"playwright/#reports","title":"Reports","text":"<ul> <li>HTML test reports are generated for every run</li> <li>Reports are uploaded as GitHub Action artifacts</li> <li>A public copy is published on GitHub Pages</li> </ul>"},{"location":"unit-tests/","title":"Overview","text":"<p>Unit tests are implemented using Jest and React Testing Library. The goal is to achieve high coverage while keeping tests meaningful and maintainable.</p>"},{"location":"unit-tests/#key-principles","title":"Key Principles","text":"<ul> <li>Test behavior, not implementation details</li> <li>Mock external libraries where necessary (e.g., Day.js)</li> <li>Use deterministic time mocks for stable snapshot-free tests</li> <li>Keep tests small and focused</li> </ul>"},{"location":"unit-tests/#coverage","title":"Coverage","text":"<p>The project reaches 100% coverage across:</p> <ul> <li>Components</li> <li>Utility functions</li> <li>Edge case handling</li> </ul> <p>Coverage thresholds are enforced in CI to prevent regressions.</p>"}]}